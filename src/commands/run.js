'use strict';

const fs = require('fs-extra');
const path = require('path');
const showdown = require('showdown');
const converter = new showdown.Converter();
const copy = require('./copy.js');
const marker = '<!-- Generated by Anodize. https://github.com/sidmani/anodize -->';

function hasExt(p, ext) {
  return p.slice(-ext.length) === ext;
}

function parse(md) {
  const firstLine = /[^\n]*/g.exec(md);
  const title = /^([^\n]*?)(?: <|$)/g.exec(firstLine)[1];
  const body = converter.makeHtml(/^[\W\w]*?\n([\W\w]*)/g.exec(md)[1]);
  const keys = { title, body };

  const keyRegex = /<([\w]+?):([\w\W]+?)>/g;
  let next;
  while ((next = keyRegex.exec(firstLine)) !== null) {
    keys[next[1]] = next[2];
  }
  return keys;
}

function loadTemplate(inputDir, templatePath) {
  let template = fs.readFileSync(path.join(inputDir, templatePath), 'utf8');
  return template.replace(/\[\[ ([\W\w]+?) \]\]/g, (match, path) => loadTemplate(inputDir, path));
}

function parseBound(bound, length) {
  const match = /^(\$)$|^(\$-)?([\d]+)$/g.exec(bound);
  if (match[1]) { return length; }
  if (match[2]) { return Math.max(0, length - parseInt(match[3], 10)); }
  return Math.min(parseInt(match[3], 10), length);
}

function paste(obj, template) {
  let result = template;
  const staticReplace = /{{ ([^\{\}]+?) }}/g;
  const dynamicReplace = /<< ([^\[\]|]+?)\[([^\[\]]+?),([^\[\]]+?)\] \| ([\W\w]+?) >>/g;
  const conditionalReplace = /\?\? ([^?|]+?) \| ([^?]+?) \?\?/g;
  const markdownReplace = /<\( ([\W\w]*?) \)>/g;
  result = result.replace(staticReplace, (match, key) => {
    if (typeof obj[key] === 'string') {
      return obj[key];
    }
    return match;
  });

  result = result.replace(dynamicReplace, (match, key, lower, upper, repeatedTemplate) => {
    const arr = obj[key];
    if (Array.isArray(arr) && lower) {
      lower = parseBound(lower, arr.length);
      upper = parseBound(upper, arr.length);
      let list = '';
      for (let i = lower; i < upper && i < arr.length; i++) {
        list = paste(arr[i], repeatedTemplate) + list;
      }
      return list;
    }
  });

  result = result.replace(markdownReplace, (match, md) => converter.makeHtml(md));

  result = result.replace(conditionalReplace, (match, key, conditionalTemplate) => {
    let invert = false
    if (key.substr(0,1) === '!') {
      key = key.substr(1);
      invert = true;
    }
    if ((obj[key] ? true : false) === !invert) {
      return paste(obj, conditionalTemplate);
    }
    return '';
  });

  return result;
}

function enumerateFiles(directory, files = []) {
  fs.readdirSync(directory)
    .filter(obj => obj.substr(0, 1) !== '.') // ignore dotfiles
    .forEach(obj => {
      const filePath = path.join(directory, obj);
      const lstat = fs.lstatSync(filePath);
      if (lstat.isDirectory()) {
        files = enumerateFiles(filePath, files);
      } else if (lstat.isFile()) {
        files.push(filePath);
      }
    });
  return files;
}

function run(inputDir, outputDir, extension) {
  // list directories
  const objects = enumerateFiles(inputDir);

  // get relevant files
  const markdownFiles = objects.filter(obj => hasExt(obj, '.md'));
  const transformTemplates = objects.filter(obj => hasExt(obj, '.tt'));

  const indices = {};
  markdownFiles.forEach(p => {
    const file = fs.readFileSync(p, 'utf8');
    const obj = parse(file);
    obj.id = path.basename(p).slice(0, -3);
    const dir = path.basename(path.dirname(p));
    if (indices[dir]) {
      indices[dir].push(obj);
    } else {
      indices[dir] = [obj];
    }
    indices[dir].path = p;
  });

  Object.keys(indices).forEach(key => {
    indices[key] = indices[key].sort((a, b) => (a.sort || 0) - (b.sort || 0));
    const p = indices[key].path;
    try {
      const template = loadTemplate(inputDir, path.join(path.relative(inputDir, path.dirname(p)), 'template.t'));
      indices[key].forEach((obj, idx, arr) => {
        if (arr[idx-1]) {
          obj.prev = arr[idx-1].id;
        }
        if (arr[idx+1]) {
          obj.next = arr[idx+1].id;
        }
        const html = marker + '\n' + paste(obj, template);
        fs.outputFileSync(path.join(outputDir, path.relative(inputDir, path.dirname(p)), obj.id + '.' + extension), html);
      });
    } catch (e) {
      console.log('Warning: no template.t in ' + path.dirname(p));
    }
  });
  transformTemplates.forEach(p => {
    const relative_path = path.relative(inputDir, p);
    let template = loadTemplate(inputDir, relative_path);
    const html =  marker + '\n' + paste(indices, template);
    fs.outputFileSync(path.join(outputDir, relative_path.slice(0, -3) + '.' + extension), html);
  });
}

exports.command = 'run';
exports.describe = 'run the generator';

exports.builder = {
  'no-static': {
    describe: 'disable the static copy phase',
    boolean: true,
    default: false,
  }
}

exports.handler = function (argv) {
  if (!argv['no-static']) {
    copy.handler(argv);
  }
  const src_path = path.join(argv.input, argv.source);
  const target_path = path.join(argv.input, argv.target);
  run(src_path, target_path, argv.extension);
};
