'use strict';

const fs = require('fs-extra');
const path = require('path');
const showdown = require('showdown');
const copy = require('./copy.js');
const htmg = require('../htmg.js');
const liquid = require('liquidjs');
const { parse } = require('./parse.js');

const converter = new showdown.Converter();

const marker = '<!-- Generated by Anodize. https://github.com/sidmani/anodize -->';

function hasExt(p, ext) {
  return p.slice(-ext.length) === ext;
}

function enumerateFiles(directory, files = []) {
  fs.readdirSync(directory)
    .filter(obj => obj.substr(0, 1) !== '.') // ignore dotfiles
    .forEach((obj) => {
      const filePath = path.join(directory, obj);
      const lstat = fs.lstatSync(filePath);
      if (lstat.isDirectory()) {
        files = enumerateFiles(filePath, files);
      } else if (lstat.isFile()) {
        files.push(filePath);
      }
    });
  return files;
}

function render(mdObject, indices, engine, template) {
  return engine.parseAndRender(mdObject.body, indices)
    .then((body) => {
      mdObject.body = converter.makeHtml(body);
      return engine.parseAndRender(template, mdObject);
    });
  // 1. render body against indices
  // 2. parse body md -> html
  // 3. render whole object against general template
}

function run(inputDir, outputDir, extension, head, templateDir) {
  const engine = new liquid({
    root: templateDir,
  });
  engine.registerFilter('markdown', md => converter.makeHtml(md));

  // list directories
  const objects = enumerateFiles(inputDir);

  // get relevant files
  const markdownFiles = objects.filter(obj => hasExt(obj, '.md'));

  const indices = {};
  markdownFiles
    .forEach((p) => {
      const file = fs.readFileSync(p, 'utf8');
      const obj = parse(file);
      obj.id = path.basename(p).slice(0, -3);
      const dir = path.basename(path.dirname(p));
      if (indices[dir]) {
        indices[dir].push(obj);
      } else {
        indices[dir] = [obj];
      }
      indices[dir].path = p;
    });

  Object.keys(indices).forEach((key) => {
    indices[key] = indices[key].sort((a, b) => (b.sort || 0) - (a.sort || 0));
    const p = indices[key].path;
    let templateName;

    try {
      indices[key].forEach((obj, idx, arr) => {
        if (obj.id === 'index') {
          templateName = 'index.t';
        } else {
          templateName = path.dirname(path.relative(inputDir, p)) + '.t';
        }
        const template = fs.readFileSync(path.join(templateDir, templateName), 'utf8');
        if (arr[idx - 1]) {
          obj.next = arr[idx - 1].id;
        }
        if (arr[idx + 1]) {
          obj.prev = arr[idx + 1].id;
        }
        engine.parseAndRender(obj.body, indices)
          .then((body) => {
            obj.body = converter.makeHtml(body);
            return engine.parseAndRender(template, obj);
          })
          .then((res) => {
            const html = `${marker}\n${htmg.buildDocument(res, head)}`;

            fs.outputFileSync(path.join(outputDir, path.relative(inputDir, path.dirname(p)), `${obj.id}.${extension}`), html);
          })
          .catch(console.log);
      });
    } catch (e) {
      console.log('Warning: could not find ' + templateName);
    }
  });
}

exports.command = 'run';
exports.describe = 'run the generator';

exports.builder = {
  'no-static': {
    describe: 'skip the static copy phase',
    boolean: true,
    default: false,
  },
  indexify: {
    describe: 'create each non-index file as the index of its own directory, allowing access as /file/ instead of /file.html',
    boolean: true,
    default: false,
  },
};

exports.handler = function handler(argv) {
  if (!argv['no-static']) {
    copy.handler(argv);
  }
  run(argv.path.source, argv.path.target, argv.extension, argv.head, argv.path.template);
};
