'use strict';

const fs = require('fs-extra');
const path = require('path');
const showdown = require('showdown');
const copy = require('./copy.js');
const htmg = require('../htmg.js');
const liquid = require('liquidjs');

const converter = new showdown.Converter();

const marker = '<!-- Generated by Anodize. https://github.com/sidmani/anodize -->';

function hasExt(p, ext) {
  return p.slice(-ext.length) === ext;
}

function parse(md) {
  const firstLine = /[^\n]*/g.exec(md);
  const title = /^([^\n]*?)(?: <|$)/g.exec(firstLine)[1];
  const body = converter.makeHtml(/^[\W\w]*?\n([\W\w]*)/g.exec(md)[1]);
  const keys = { title, body };

  const keyRegex = /<([\w]+?):([\w\W]+?)>/g;
  let next;
  while ((next = keyRegex.exec(firstLine)) !== null) {
    keys[next[1]] = next[2];
  }
  return keys;
}

function enumerateFiles(directory, files = []) {
  fs.readdirSync(directory)
    .filter(obj => obj.substr(0, 1) !== '.') // ignore dotfiles
    .forEach((obj) => {
      const filePath = path.join(directory, obj);
      const lstat = fs.lstatSync(filePath);
      if (lstat.isDirectory()) {
        files = enumerateFiles(filePath, files);
      } else if (lstat.isFile()) {
        files.push(filePath);
      }
    });
  return files;
}

function run(inputDir, outputDir, extension, head) {
  const engine = new liquid({
    root: inputDir,
  });
  engine.registerFilter('markdown', md => converter.makeHtml(md))

  // list directories
  const objects = enumerateFiles(inputDir);

  // get relevant files
  const markdownFiles = objects.filter(obj => hasExt(obj, '.md'));
  const transformTemplates = objects.filter(obj => hasExt(obj, '.tt'));

  const indices = {};
  markdownFiles.forEach((p) => {
    const file = fs.readFileSync(p, 'utf8');
    const obj = parse(file);
    obj.id = path.basename(p).slice(0, -3);
    const dir = path.basename(path.dirname(p));
    if (indices[dir]) {
      indices[dir].push(obj);
    } else {
      indices[dir] = [obj];
    }
    indices[dir].path = p;
  });

  Object.keys(indices).forEach((key) => {
    indices[key] = indices[key].sort((a, b) => (b.sort || 0) - (a.sort || 0));
    const p = indices[key].path;
    try {
      const template = fs.readFileSync(path.join(path.dirname(p), 'template.t'), 'utf8');
      indices[key].forEach((obj, idx, arr) => {
        if (arr[idx - 1]) {
          obj.next = arr[idx - 1].id;
        }
        if (arr[idx + 1]) {
          obj.prev = arr[idx + 1].id;
        }
        engine.parseAndRender(template, obj)
          .then(res => {
            const html = `${marker}\n${htmg.buildDocument(res, head)}`;
            fs.outputFileSync(path.join(outputDir, path.relative(inputDir, path.dirname(p)), `${obj.id}.${extension}`), html);
          })
          .catch(console.log);
      });
    } catch (e) {
      console.log('Warning: no template.t in ' + path.dirname(p));
    }
  });

  transformTemplates.forEach((p) => {
    const template = fs.readFileSync(p, 'utf8');
    engine.parseAndRender(template, indices)
      .then(res => {
        const html = `${marker}\n${htmg.buildDocument(res, head)}`;
        fs.outputFileSync(path.join(outputDir, path.relative(inputDir, p).slice(0, -3) + '.' + extension), html);
      })
      .catch(console.log);
  });
}

exports.command = 'run';
exports.describe = 'run the generator';

exports.builder = {
  'no-static': {
    describe: 'skip the static copy phase',
    boolean: true,
    default: false,
  },
};

exports.handler = function handler(argv) {
  if (!argv['no-static']) {
    copy.handler(argv);
  }
  run(argv.path.source, argv.path.target, argv.extension, argv.head);
};
